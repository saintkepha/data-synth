// Generated by CoffeeScript 1.9.1
(function() {
  var ModelRegistry, ModelRegistryProperty, StormModel, StormRegistry,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  StormRegistry = require('./registry');

  ModelRegistryProperty = (function(superClass) {
    extend(ModelRegistryProperty, superClass);

    function ModelRegistryProperty(model1, opts, obj) {
      this.model = model1;
      ModelRegistryProperty.__super__.constructor.call(this, 'object', opts, obj);
    }

    ModelRegistryProperty.prototype.match = function(query, keys) {
      var k, ref, results, v;
      if (keys == null) {
        keys = false;
      }
      switch (false) {
        case !(query instanceof Array):
          return ModelRegistryProperty.__super__.match.apply(this, arguments);
        case !(query instanceof Object):
          ref = this.get();
          results = [];
          for (k in ref) {
            v = ref[k];
            if (v.match(query)) {
              if (keys) {
                results.push(k);
              } else {
                results.push(v);
              }
            }
          }
          return results;
          break;
        default:
          return ModelRegistryProperty.__super__.match.apply(this, arguments);
      }
    };

    ModelRegistryProperty.prototype.serialize = function(format) {
      if (format == null) {
        format = 'json';
      }
      return {
        ids: Object.keys(this.value),
        numRecords: Object.keys(this.value).length
      };
    };

    return ModelRegistryProperty;

  })(StormRegistry.Property);

  ModelRegistry = (function(superClass) {
    extend(ModelRegistry, superClass);

    function ModelRegistry() {
      return ModelRegistry.__super__.constructor.apply(this, arguments);
    }

    ModelRegistry.Property = ModelRegistryProperty;

    ModelRegistry.prototype.register = function(model, opts) {
      return ModelRegistry.__super__.register.call(this, model.meta.name, new ModelRegistryProperty(model, opts, this));
    };

    ModelRegistry.prototype.add = function() {
      var i, len, obj, record, records;
      records = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      obj = {};
      for (i = 0, len = records.length; i < len; i++) {
        record = records[i];
        if (record instanceof StormModel) {
          obj[record.get('id')] = record;
        }
      }
      return ModelRegistry.__super__.add.call(this, record.constructor.meta.name, obj);
    };

    ModelRegistry.prototype.remove = function() {
      var query, record, records;
      records = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      query = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = records.length; i < len; i++) {
          record = records[i];
          if (record instanceof StormModel) {
            results.push(record.get('id'));
          }
        }
        return results;
      })();
      return ModelRegistry.__super__.remove.call(this, record.constructor.meta.name, query);
    };

    ModelRegistry.prototype.contains = function(key) {
      return this.getProperty(key);
    };

    return ModelRegistry;

  })(StormRegistry);

  StormModel = (function(superClass) {
    var Promise;

    extend(StormModel, superClass);

    StormModel.set({
      storm: 'model'
    });

    StormModel.belongsTo = function(model, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: model,
          opts: opts
        });

        return _Class;

      })(require('./property/belongsTo'));
    };

    StormModel.hasMany = function(model, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: model,
          opts: opts
        });

        return _Class;

      })(require('./property/hasMany'));
    };

    StormModel.action = function(func, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          func: func,
          opts: opts
        });

        return _Class;

      })(require('./property/action'));
    };

    StormModel.id = StormModel.attr('string', {
      "private": true,
      defaultValue: function() {
        return (require('node-uuid')).v4();
      }
    });

    StormModel.createdOn = StormModel.attr('date', {
      "private": true,
      defaultValue: function() {
        return new Date;
      }
    });

    StormModel.modifiedOn = StormModel.attr('date', {
      "private": true,
      defaultValue: function() {
        return new Date;
      }
    });

    StormModel.accessedOn = StormModel.attr('date', {
      "private": true,
      defaultValue: function() {
        return new Date;
      }
    });

    StormModel._bindings = StormModel.hasMany(StormModel, {
      "private": true
    });

    StormModel.prototype._models = new ModelRegistry;

    function StormModel() {
      StormModel.__super__.constructor.apply(this, arguments);
      this._models.register(this.constructor);
      this._models.add(this);
    }

    StormModel.prototype.get = function() {
      this.set('accessedOn', new Date);
      return StormModel.__super__.get.apply(this, arguments);
    };

    StormModel.prototype.fetch = function(id) {
      return this._models.find(this.constructor.meta.name, id);
    };

    StormModel.prototype.getRelationships = function(kind) {
      return this.everyProperty(function(key) {
        if (this instanceof RelationshipProperty) {
          return this;
        }
      }).filter(function(x) {
        return (x != null) && ((kind == null) || kind === x.kind);
      });
    };


    /**
     * `bind` subjugates passed in records to be bound to the lifespan of
     * the current model record.
    #
     * When this current model record is destroyed, all bound dependents
     * will also be destroyed.
     */

    StormModel.prototype.bind = function() {
      var i, len, record, records, results;
      records = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = records.length; i < len; i++) {
        record = records[i];
        if (!((record != null) && record instanceof StormModel)) {
          continue;
        }
        results.push((this.getProperty('_bindings')).push(record.save()));
      }
      return results;
    };

    StormModel.prototype.match = function(query) {
      var k, ref, v, x;
      for (k in query) {
        v = query[k];
        x = (ref = this.getProperty(k)) != null ? ref.normalize(this.get(k)) : void 0;
        if (typeof x === 'boolean' && typeof v === 'string') {
          x = "" + x;
        }
        if (x !== v) {
          return false;
        }
      }
      return true;
    };

    StormModel.prototype.save = function() {
      var isValid;
      isValid = this.validate();
      if (isValid.length === 0) {
        if (this.isDirty()) {
          this.set('modifiedOn', new Date);
        }
        this.clearDirty();
        this._models.add(this);
        return this;
      } else {
        return null;
      }
    };

    StormModel.prototype.destroy = function() {
      var i, len, record, ref;
      ref = this.get('_bindings');
      for (i = 0, len = ref.length; i < len; i++) {
        record = ref[i];
        record.destroy();
      }
      return this._models.remove(this);
    };

    Promise = require('promise');

    StormModel.prototype.invoke = function() {
      var action, args;
      action = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var err, ref;
          try {
            if (!(action instanceof Function)) {
              action = (ref = _this.getProperty(action)) != null ? ref.exec : void 0;
            }
            return resolve(action != null ? action.apply(_this, args) : void 0);
          } catch (_error) {
            err = _error;
            return reject(err);
          }
        };
      })(this));
    };

    return StormModel;

  })(require('./object'));

  module.exports = StormModel;

}).call(this);
