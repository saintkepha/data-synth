// Generated by CoffeeScript 1.9.1
(function() {
  var ComputedProperty, StormClass, StormObject, StormProperty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  StormClass = require('./class');

  StormProperty = require('./property');

  ComputedProperty = require('./property/computed');

  StormObject = (function(superClass) {
    extend(StormObject, superClass);

    StormObject.set({
      storm: 'object'
    });

    StormObject.attr = function(type, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: type,
          opts: opts
        });

        return _Class;

      })(StormProperty);
    };

    StormObject.computed = function(func, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: func,
          opts: opts
        });

        return _Class;

      })(ComputedProperty);
    };

    function StormObject(data, opts1, container) {
      var StormConstructor, input, key, ref, ref1;
      this.opts = opts1 != null ? opts1 : {};
      this.container = container;
      this._properties = {};
      ref = this.constructor;
      for (key in ref) {
        StormConstructor = ref[key];
        if (!(key !== 'constructor' && ((StormConstructor != null ? (ref1 = StormConstructor.meta) != null ? ref1.storm : void 0 : void 0) != null))) {
          continue;
        }
        input = (function() {
          switch (StormConstructor.get('storm')) {
            case 'object':
              return 'data';
            default:
              return 'type';
          }
        })();
        this.addProperty(key, new StormConstructor(StormConstructor.get(input), StormConstructor.get('opts'), this));
      }
      this.everyProperty(function(key) {
        return this.set(void 0, {
          skipValidation: true
        });
      });
      if (data != null) {
        this.set(data, {
          skipValidation: true
        });
      }
    }

    StormObject.prototype.keys = function() {
      return Object.keys(this._properties);
    };

    StormObject.prototype.addProperty = function(key, property) {
      if (!(this.hasProperty(key)) && property instanceof StormClass) {
        this._properties[key] = property;
      }
      return property;
    };

    StormObject.prototype.removeProperty = function(key) {
      if (this.hasProperty(key)) {
        return delete this._properties[key];
      }
    };

    StormObject.prototype.hasProperty = function(key) {
      return this._properties.hasOwnProperty(key);
    };


    /**
     * `getProperty` supports retrieving property based on composite key such as:
     * 'hello.world.bye'
    #
     * Since this routine is the primary function for get/set operations,
     * you can also use it to specify nested path during those operations.
     */

    StormObject.prototype.getProperty = function(key) {
      var composite, i, len, prop;
      if (key == null) {
        return;
      }
      composite = key != null ? key.split('.') : void 0;
      key = composite.shift();
      if (this.hasProperty(key)) {
        prop = this._properties[key];
      }
      for (i = 0, len = composite.length; i < len; i++) {
        key = composite[i];
        if (prop == null) {
          return;
        }
        prop = typeof prop.getProperty === "function" ? prop.getProperty(key) : void 0;
      }
      return prop;
    };

    StormObject.prototype.get = function() {
      var i, key, keys, len, ref, ref1, result;
      keys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = {};
      switch (false) {
        case keys.length !== 0:
          this.everyProperty(function(key) {
            return result[key] = this.get();
          });
          break;
        case keys.length !== 1:
          result = (ref = this.getProperty(keys[0])) != null ? ref.get() : void 0;
          break;
        default:
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            result[key] = (ref1 = this.getProperty(key)) != null ? ref1.get() : void 0;
          }
      }
      return result;
    };


    /**
     * `set` is used to place values on matching StormProperty
     * instances. Accepts an object of key/values
    #
     * obj.set hello:'world'
    #
     * { hello: 'world' }
    #
     * obj.set test:'a', sample:'b'
    #
     * obj.set 'test.nested.param':'a', sample:'b'
    #
     * also takes in `opts` as an optional param object to override
     * validations and other special considerations during the `set`
     * execution.
     */

    StormObject.prototype.set = function(obj, opts) {
      var key, ref, value;
      if (!(obj instanceof Object)) {
        return;
      }
      for (key in obj) {
        value = obj[key];
        if ((ref = this.getProperty(key)) != null) {
          ref.set(value, opts);
        }
      }
      return this;
    };

    StormObject.prototype.everyProperty = function(func) {
      var key, prop, ref, results;
      ref = this._properties;
      results = [];
      for (key in ref) {
        prop = ref[key];
        results.push(func != null ? func.call(prop, key) : void 0);
      }
      return results;
    };

    StormObject.prototype.validate = function() {
      return (this.everyProperty(function(key) {
        return {
          name: key,
          isValid: this.validate()
        };
      })).filter(function(e) {
        return e.isValid === false;
      });
    };

    StormObject.prototype.serialize = function(format) {
      var o;
      if (format == null) {
        format = 'json';
      }
      o = (function() {
        switch (format) {
          case 'json':
            return {};
          default:
            return '';
        }
      })();
      this.everyProperty(function(key) {
        switch (format) {
          case 'json':
            return o[key] = this.serialize(format);
          case 'xml':
            return o += ("<" + key + ">") + (this.serialize(format)) + ("</" + key + ">");
        }
      });
      return o;
    };

    StormObject.prototype.clearDirty = function() {
      return this.everyProperty(function() {
        return this.isDirty = false;
      });
    };

    StormObject.prototype.dirtyProperties = function(keys) {
      return (this.everyProperty(function(key) {
        var ref;
        return (ref = this.isDirty) != null ? ref : key;
      })).filter(function(x) {
        if (keys != null) {
          return (x != null) && indexOf.call(keys, x) >= 0;
        } else {
          return x != null;
        }
      });
    };

    StormObject.prototype.isDirty = function(keys) {
      if ((keys != null) && !(keys instanceof Array)) {
        keys = [keys];
      }
      return (this.dirtyProperties(keys)).length > 0;

      /* for future optimization reference
      dirty = @dirtyProperties().join ' '
      keys.some (prop) -> ~dirty.indexOf prop
       */
    };

    return StormObject;

  })(StormClass);

  module.exports = StormObject;

}).call(this);
