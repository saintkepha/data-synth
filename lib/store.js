// Generated by CoffeeScript 1.9.1
(function() {
  var DataStore, ModelRegistry,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ModelRegistry = require('./registry/model');

  DataStore = (function(superClass) {
    var action, exists, ref, registry;

    extend(DataStore, superClass);

    function DataStore() {
      return DataStore.__super__.constructor.apply(this, arguments);
    }

    DataStore.set({
      storm: 'store',
      registry: new ModelRegistry
    });

    DataStore.include((require('events')).EventEmitter);

    DataStore.loglevel = DataStore.attr('string', {
      defaultValue: 'info'
    });

    DataStore.datadir = DataStore.attr('string', {
      defaultValue: '/tmp'
    });

    DataStore.stores = DataStore.hasMany(DataStore, {
      "private": true
    });

    DataStore.models = DataStore.computed((function() {
      return (this.constructor.get('registry')).serialize();
    }));

    DataStore.prototype.register = function() {
      var i, len, model, models, results;
      models = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = models.length; i < len; i++) {
        model = models[i];
        results.push((this.constructor.get('registry')).register(model));
      }
      return results;
    };

    DataStore.prototype.create = function(type, data) {
      return null;
    };

    DataStore.prototype.find = function(type, query) {
      return this._models.find(type, query);
    };

    DataStore.prototype.update = function(type, id, data) {
      return null;
    };

    DataStore.prototype["delete"] = function(type, query) {
      var i, len, model, ref, results;
      ref = this.find(type, query);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        model = ref[i];
        results.push(model.destroy());
      }
      return results;
    };

    DataStore.prototype.contains = function(key) {
      var prop;
      prop = this.getProperty(key);
      if (prop instanceof StormModel.Registry.Property) {
        return prop;
      }
    };

    DataStore.prototype.infuse = function(opts) {
      return console.log("using: " + (opts != null ? opts.source : void 0));
    };

    DataStore.log.debug({
      method: "commit",
      record: typeof record !== "undefined" && record !== null ? record.id : void 0
    });

    registry = (ref = DataStore.entities[record.name]) != null ? ref.registry : void 0;

    assert(registry != null, "cannot commit '" + record.name + "' into store which doesn't contain the collection");

    action = (function() {
      switch (false) {
        case !record.isDestroy:
          registry.remove(record.id);
          return 'removed';
        case !!record.isSaved:
          exists = (record.id != null) && (registry.get(record.id) != null);
          assert(!exists, "cannot commit a new record '" + record.name + "' into the store using pre-existing ID: " + record.id);
          registry.add(record.id, record);
          return 'added';
        case !record.isDirty():
          record.changed = true;
          registry.update(record.id, record);
          delete record.changed;
          return 'updated';
      }
    })();

    if (action != null) {
      DataStore.emit('commit', [action, record.name, record.id]);
      DataStore.log.info({
        method: "commit",
        id: record.id
      }, action + " '%s' on the store registry", record.constructor.name);
    }

    return DataStore;

  })(require('./model'));

}).call(this);
